<!--- 
******* DO NOT EDIT THIS FILE ********
******* DO NOT EDIT THIS FILE ********
******* DO NOT EDIT THIS FILE ********
******* DO NOT EDIT THIS FILE ********
******* DO NOT EDIT THIS FILE ********
For information about how to configure application events, 
see /docs/index.cfm?netaction=quickstart/events 
**************************************

 * onTap Framework Copyright (c) 2003-2009 
 * Autelligent Laboratories (AutLabs) and S. Isaac Dealey.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgment:
 *	This product includes software developed by AutLabs and S. Isaac Dealey.
 * 4. Neither the name of AutLabs, S. Isaac Dealey or other contributors 
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
--->

<cfcomponent output="false">
	<cfset structAppend(this,getTap().getCF().app,true)>
	
	<cfif getTap().getCF().app.loginstorage is "session" 
	and not getTap().getCF().app.sessionmanagement>
		<cfset getTap().getCF().app.loginstorage = "cookie">
	</cfif>
	
	<cfset this.customtagpaths = ArrayToList(this.customtagpaths)>
	<cfset this.applicationtimeout = CreateTimeSpan(0,this.timeout_application,0,0)>
	<cfif this.sessionmanagement>
		<cfset this.sessiontimeout = CreateTimeSpan(0,0,this.timeout_session,0)>
	</cfif>
	
	<cffunction name="getTap" access="private" output="false">
		<cfif not structkeyexists(request,"tap")>
			<cfinclude template="_preapp.cfm" />
		</cfif>
		<cfreturn request.tap />
	</cffunction>
	
	<cffunction name="onMissingMethod" access="public" output="false" returntype="boolean">
		<cfreturn true />
	</cffunction>
	
	<cffunction name="getLib" access="public" output="false">
		<cfreturn request.tapi />
	</cffunction>
	
	<cffunction name="getFS" access="public" output="false">
		<cfreturn request.fs />
	</cffunction>
	
	<cffunction name="getIoC" access="public" output="false">
		<cfargument name="container" type="string" required="false" default="" hint="a specific IoC Container name" />
		<cfreturn getTap().getIoC(container) />
	</cffunction>
	
	<cffunction name="loadRequestLibraries" access="private" output="false" returntype="void">
		<cfargument name="ApplicationScope" type="struct" required="false" default="#structNew()#" />
		<cfset getTap().getLibraryManager(ApplicationScope).initRequest()>
	</cffunction>
	
	<cffunction name="CreateSessionManager" access="private" output="false">
		<!--- create a SessionManager object to provide access to all sessions in the application in a supported manner --->
		<cflock name="tap.sessionmanager.#this.name#" type="exclusive" timeout="10">
			<cfparam name="application.tap" type="struct" default="#StructNew()#" />
			<cfif not structKeyExists(application.tap,"SessionManager")>
				<cfparam name="this.sessionman" default="sessionmanager" />
				<cfset application.tap.SessionManager = CreateObject("component",this.sessionman) />
			</cfif>
		</cflock>
	</cffunction>
	
	<cffunction name="onApplicationStart" access="public" output="true">
		<cfset var restart = false />
		<cfset var tap = getTap() />
		
		<cfif not tap.hasLibraryManager()>
			<cfset tap.testCriticalMappings() />
			<cfset tap.testCustomTags() />
			<cfset CreateSessionManager() />
			
			<cfset loadRequestLibraries(Application) />
			<cfset application.FreeAgent = tap.getIoCManager() />
			<cfset tap.setIoC(Application.FreeAgent) />
			<cfset tap.loadPathSettings() />
			
			<cfset tap.executeApplicationEvent("ApplicationStart") />
			
			<cfset application.tap.appstart.time = getLib().now() />
		</cfif>
	</cffunction>
	
	<cffunction name="onApplicationEnd" access="public" output="false">
		<cfargument name="ApplicationScope" required="true">
		
		<cfset getAppVars(ApplicationScope)>
		
		<cfset getTap().executeApplicationEvent(eventName="ApplicationEnd",applicationScope=applicationScope) />
	</cffunction>
	
	<cffunction name="getAppVars" access="private" output="true">
		<cfargument name="ApplicationScope" type="any" required="false" default="#structNew()#" />
		<cfset var tap = getTap() />
		<cfset var x = 0 />
		<cfset var y = 0 />
		
		<cfif isDefined("ApplicationScope.tap.IoCManager")>
			<!--- make framework functions accessible to onSessionEnd and onApplicationEnd events --->
			<cfset tap.appstart.time = applicationScope.tap.appstart.time />
			<cfset tap.setIoC(ApplicationScope.tap.IoCManager)>
			<cfset loadRequestLibraries(ApplicationScope)>
		<cfelseif tap.development or not isDefined("application.tap.appstart.time")>
			<!--- don't pass the request scope to prevent the framework from using the IoC Manager --->
			<cfset onApplicationStart()>
			<cfset tap.appstart.time = application.tap.appstart.time />
		<cfelse>
			<cfset tap.appstart.time = application.tap.appstart.time />
			<cfset tap.setIoC(application.FreeAgent) />
			<cfset loadRequestLibraries(Application) />
		</cfif>
	</cffunction>
	
	<cffunction name="onRequestStart" access="public" output="true">
		<cfargument name="targetPage" type="string" required="true">
		<cfset var _bt = getBaseTemplatePath() />
		<cfset var _tap = getTap() />
		<cfset getAppVars() />
		
		<!--- abort the request if an unsupported http request method is used --->
		<cfif len(trim(cgi.request_method)) and not 
		listfindnocase(_tap.http_request_methods,cgi.request_method)><cfabort></cfif>
		
		<!--- don't let anyone have direct access to files in the /_tap/ directory --->
		<cfif _tap.getPath().isInternalFile()>
			<cfsetting showdebugoutput="false" />
			<cfabort>
		</cfif>
		
		<!--- set the language for the current request --->
		<cfif isDefined("session.tap.L10N.language")>
			<cfset _tap.getLocal().language = session.tap.L10N.language />
		</cfif>
		
		<!--- include code for the application stage which initializes the request --->
		<cfinclude template="#request.fs.getPathTo(_tap.getPath().components & '/_prerequest.cfm','C')#">
		
		<!--- 
			if this is not a webservice or flash remoting call, 
			then we can bypass the onRequest() event by loading the target page here 
			and ending the request - this allows us to support both webservices in 
			the root directory and sharing the variables scope with the event controller 
		--->
		<cfif not refindnocase("\.cfc$",_bt)>
			<cfif fileExists(_bt)>
				<cfinclude template="#request.fs.getPathTo(_bt)#" />
			<cfelse>
				<cfinclude template="/tags/process.cfm" />
			</cfif>
			<cfset onRequestEnd() />
			<cfabort>
		</cfif>
	</cffunction>
	
	<cffunction name="onRequestEnd" access="public" output="true">
		<cfinclude template="OnRequestEnd.cfm">
	</cffunction>
	
	<cffunction name="manageSession" access="private" output="false" 
	hint="adds the current session to the application.tap.SessionManager object">
		<cfset application.tap.SessionManager.add(session)>
	</cffunction>
	
	<cffunction name="expireSession" access="private" output="false" 
	hint="adds the current session to the application.tap.SessionManager object">
		<cfargument name="SessionScope" type="struct" required="true">
		<cfargument name="ApplicationScope" required="true">
		<cfset applicationScope.tap.SessionManager.expire(SessionScope.SessionID)>
	</cffunction>
	
	<cffunction name="onSessionStart" access="public" output="false">
		<cfset getAppVars(Application)>
		<cfset ManageSession()>
		<cfset getTap().executeApplicationEvent("SessionStart") />
	</cffunction>
	
	<cffunction name="onSessionEnd" access="public" output="false">
		<cfargument name="SessionScope" required="true">
		<cfargument name="ApplicationScope" required="true">
		<cfset var x = 0>
		<cfset var y = 0>
		
		<cfset getAppVars(ApplicationScope)>
		
		<!--- remove the current session from application management before performing any other cleanup tasks --->
		<cfset ExpireSession(SessionScope,ApplicationScope)>
		
		<!--- execute custom sessionend code for all plugin applications --->
		<cfset getTap().executeApplicationEvent("SessionEnd",sessionScope,applicationScope) />
		
		<!--- delete any cache that might have been stored for the session --->
		<cfset getTap().getIoC().getBean("cachemanager").getAgent("session").delete(SessionScope.SessionID & ".%") />
	</cffunction>
	
	<cffunction name="onMissingTemplate" access="public" output="true">
		<cfargument name="targetPage" type="string" required="true" />
		
		<cftry>
			<cfset onRequestStart(targetPage) />
			<cfreturn true />
			
			<cfcatch><cfrethrow /></cfcatch>
		</cftry>
	</cffunction>
</cfcomponent>
